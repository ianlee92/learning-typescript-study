## Ch.5 함수

5.1.2
선택적 매개변수는 필수 매개변수 전에 위치할 수 없습니다.

5.1.3
선택적 매개변수에는 기본적으로 값이 제공되기 때문에 해당 타입스크립트 타입에는 암묵적으로 함수 내부에 | undefined 유니언 타입이 추가됩니다.

5.2.1
변수와 마찬가지로 타입 애너테이션을 이용해 함수의 반환 타입을 명시적으로 선언하지 않는 것이 좋습니다. 그러나 반환 타입을 명시하는 것이 매우 유용할 때가 몇 가지 있습니다.

e.g

> 반환값이 많은 함수가 항상 동일한 타입의 값을 반환하도록 강제합니다.
> 규모가 큰 프로젝트의 경우 타입 검사 속도를 높일 수 있습니다.

5.5
함수 오버로드는 복잡하고 설명하기 어려운 함수 타입에 사용하는 최후의 수단입니다.

Q. 112쪽에 saveRecords 함수의 record.push(record)는~ 이 단락의 끝에 여전히 newRecords.forEach에 전달된 화살표 함수에 대한 반환값이 허용됩니다. 이게 무슨 말인지 이해가 잘 안돼요!

Q. 5.4.2의 never 반환 타입에서 의도적으로 오류를 발생시키는 건 이해가 되는데, 의도적으로 무한 루프를 실행시키는 건 대체 어떤 경우일까요?

## Ch.6 배열

타입스크립트는 변수의 초기값으로 변수 타입을 유추하는 것과 동일한 방식으로 초기 배열에 담긴 요소를 통해 배열의 타입을 유추합니다.

6.1.2
즉, 배열의 요소 타입은 배열에 담긴 요소에 대한 모든 가능한 타입의 집합입니다.

6.1.4
2차원 배열 또는 배열의 배열은 두 개의 []를 갖습니다.
예를 들어

```
array = [
[1,2,3],
[4,5,6],
[7,8,9]
]
```

일 때 array의 타입은 `number[][]` 또는 `(number[])[]`로 표현할 수 있습니다.

6.2.1. 주의사항 (제일 흥미로웠던 파트)
타입스크립트는 검색된 배열의 멤버가 존재하는지 의도적으로 확인하지 않습니다. 자바스크립트에서조차 배열의 길이보다 큰 인덱스에 접근하면 undefined를 제공하지만 타입스크립트는 배열의 길이보다 큰 인덱스에 접근해도 undefined가 아닌 배열의 기존 타입과 같은 타입으로 간주합니다.

6.4
튜플 타입을 선언하는 구문은 배열 리터럴처럼 보이지만 요소의 값 대신 타입을 적습니다.

6.4.1
타입스크립트는 튜플 타입의 튜플에 얼마나 많은 멤버가 있는지 알고 있기 때문에 길이가 다른 튜플은 서로 할당할 수 없습니다.

6.4.2
const 어서션은 타입스크립트에 타입을 유추할 때 읽기 전용이 가능한 값 형식을 사용하도록 지시합니다. const 어서션은 유연한 크기의 배열을 고정된 크기의 튜플로 전환하는 것을 넘어서, 해당 튜플이 읽기 전용이고 값 수정이 예상되는 곳에서 사용할 수 없음을 나타냅니다.

## Ch.7 인터페이스

인터페이스는 연관된 이름으로 객체 형태를 설명하는 또 다른 방법입니다.

- 인터페이스는 속성 증가를 위해 병합할 수 있습니다.
- 인터페이스는 클래스가 선언된 구조의 타입을 확인하는 데 사용할 수 있지만 타입 별칭은 사용할 수 없습니다.
- 인터페이스는 이름 있는 객체로 간주되므로 어려운 특이 케이스에 나타나는 오류 메시지를 더 쉽게 읽을 수 있습니다.

  7.2.2
  readonly 제한자는 객체의 인터페이스를 선언하는 위치에서만 사용되고 실제 객체에는 적용되지 않습니다.

  7.2.3

- 메서드는 readonly로 선언할 수 없지만 속성은 가능합니다.
- 인터페이스 병합은 메서드와 속성을 다르게 처리합니다.
- 타입에서 수행되는 일부 작업은 메서드와 속성을 다르게 처리합니다.

기본 함수가 this를 참조할 수 있다는 것을 알고 있다면 메서드 함수를 사용하세요. 일반적으로 클래스의 인스턴스에서 사용됩니다. 반대의 경우 속성 함수를 사용하세요.

7.2.5
타입스크립트는 인덱스 시그니처 구문을 제공해 인터페이스의 객체가 임의의 키를 받고, 해당 키 아래의 특정 타입을 반환할 수 있음을 나타냅니다. 인덱스 시그니처는 객체에 값을 할당할 때 편리하지만 타입 안정성을 완벽히 보장하지는 않습니다. 인덱스 시그니처는 객체가 어떤 속성에 접근하든 간에 값을 반환해야 함을 나타냅니다.

7.3
타입스크립트는 인터페이스가 다른 인터페이스의 모든 멤버를 복사해서 선언할 수 있는 extend 인터페이스를 허용합니다. 확장할 인터페이스 이름 뒤에 extends 키워드를 추가해서 다른 인터페이스를 확장한 인터페이스라는 것을 표시합니다. 이렇게 하면 파생 인터페이스를 준수하는 모든 객체가 기본 인터페이스의 모든 멤버를 가져야 한다는 것을 타입스크립트에게 알려줍니다.
