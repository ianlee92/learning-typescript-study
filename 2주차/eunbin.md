## Chapter 5. Function

- 함수의 매개변수에 대한 타입스크립트의 타입 추론은 초기 변숫값과 유사하게 동작한다.
  - 함수 매개변수에 대한 타이핑은 주로 객체 형태로 해와서 크게 느끼지 못했다. 초기 매개변수를 통해서도 타입 추론이 가능했다.
- 나머지 매개변수의 타입도 일반 매개변수와 마찬가지로 선언할 수 있다. 다만 배열[] 구문이 추가된다.
- void와 undefined의 차이.
  - void: 함수의 반환 타입이 무시된다. 함수가 반환하는 모든 값을 무시하도록 설정할 때 유용하다.
    - ex) 자바스크립트 내장 함수 forEach() 메서드는 void를 반환하는 콜백을 받는다.
  - undefined: 말그대로 undefined가 반환된다는 것을 명시적으로 선언한 것.
- never: (의도적으로) 항상 오류를 발생시키거나 무한루프를 실행하는 함수.(절대 반환하지 않는 함수.)
- 함수 오버로드
  - 오버로드 시그니처: 구문 오류 생성 여부를 결정한다.
  - 구현 시그니처: 오버로드 시그니처와 호환되어야한다. 즉 오버로드 시그니처의 타입은 구현시그니처에 할당 가능해야 한다.
  - 어떤 함수가 있는데, 매개별수가 하나만 들어오던가 3개만 들어오던가 둘 중 하나여야한다. 2개 또는 4개, 또는 그 이상은 안됨. 이런 경우 사용할 수 있는 방식!

## Chapter 6. Array

- 초기 배열에 담긴 요소를 통해 배열의 타입을 유추하는 타입스크립트의 타입 추론은 초기 변숫값과 유사하게 동작한다.
- 배열의 요소 타입은 배열에 담긴 요소에 대한 모든 가능한 타입의 집합
- 타입스크립트에서 배열의 타입은 불안정하다.
  - 배열의 길이보다 큰 인덱스로 배열 요소에 접근하면 undefined를 제공한다. 타입스크립트는 검색된 배열의 멤버가 있다고 가정하고 동작한다.
- 튜플 타입
  - 배열 리터럴 처럼 생겼다.
  - 가변 길이 배열 타입보다 구체적. (더 엄격한 타입을 적용할 해야할 때 유용하다.)
  - 한 번에 여러 값을 할당하기 위해 튜플과 배열 구조 분해 할당을 함께 자주 이용한다.
    - 한 줄의 로직으로 변수에 초기값 할당 + 타입 정의

```jsx
let [year, warrior] = [123, "abc"];
// year 타입: number, warrior 타입: string으로 추론된다.
```

- const 어서션
  - 배열 리터럴 뒤에 as const 배치.
  - 배열이 튜플로 처리되어야함을 나타낸다.
  - read-only형식임을 지정한다.(값 수정 불가) => 함수 반환값의 타입 지정 시 유용

## Chapter 7. Interface

- (객체 타입 선언 시에) type alias vs interface
  - interface
    - 병합 가능. 내장된 전역 인터페이스 또는 npm 패키지 등 공통적으로 가져다 사용하는 타입을 정의할 때 유용
    - 클래스가 선언된 구조의 타입 확인 가능
    - 타입 검사가 빠르게 작동.
    - 명명된 객체로 간주되므로 오류케이스 읽기 쉬음.
  - 그래서 인터페이스를 사용하는 것이 더 좋다!
- 인덱스 시그니처
  - 객체의 포괄적인 속성을 담기 위함.
  - 객체의 키에 대한 타입을 지정하기 위해 사용했던 것 같은데 잘 모르겠다!
- 인터페이스 재사용하기 <- 중첩, 확장(extends)
- 인터페이스 병합
  - 외부 패키지, Window와 같은 전역 내장 인터페이스를 사용할 때 유용하다.
