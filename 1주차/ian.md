### 📅 2023년 6월 21일

# 📚 1장 자바스크립트에서 타입스크립트로
- 자바스크립트의 함정: 값 비싼 자유, 부족한 문서, 부족한 개발자 도구
- 타입스크립트의 장점: 제한을 통한 자유로움, 정확한 문서화, 강력한 개발자 도구
- 타입스크립트에 대한 오해: 잘못된 코드 해결책, 자바스크립트로의 확장, 자바스크립트보다 느림, 진화가 끝남

# 📚 2장 타입 시스템
- 타입스크립트는 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문인 타입 애너테이션을 제공합니다.
    - 타입 애너테이션: let firstName: string 처럼 세미콜론에 타입 넣어주는 것
- 타입 시스템에만 존재하는 것은 컴파일된 자바스크립트로 복사되지 않습니다. 타입스크립 타입은 컴파일을 통해 생성된 자바스크립트에 어떠한 영향도 주지 않습니다.
- 많은 개발자는 아무것도 변하지 않는 변수에는 타입 애너테이션을 추가하지 않기를 선호합니다.
- export 또는 import가 있는 파일을 ECMA스크립트 사양에서 모듈이라고 명명한다. 모듈이 아닌 모든 파일은 스크립트이다.

# 📚 3장 유니언과 리터럴
- 값이 유니언 타입일 때 타입스크립트는 유니언으로 선언한 모든 가능한 타입에 존재하는 멤버속성에만 접근할 수 있습니다. 유니언 외의 타입에 접근하려고 하면 타입 검사 오류가 발생합니다. Number | string 타입으로 두개의 타입에 모두 존재하는 toString()은 사용할 수 있지만, toUpperCase()와 toFixed()는 사용할 수 없습니다. toUpperCase()는 number타입에 없고, toFixed()는 string 타입에 없기 때문입니다. 즉, 서로 다른 원시 타입이 서로 할당되지 못한다.
- 내로잉은 값이 정의, 선언 혹은 이전에 유추된 것보다 더 구체적인 타입임을 코드에서 유추하는 것입니다. 타입을 좁히는 데 사용할 수 있는 논리적 검사를 타입 가드(type guard)라고 한다.
    - 값 할당을 통한 내로잉: 먼저 할당된 값 또는 초깃값 주어질 때 (변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 값 할당 내로잉이 작동한다. 초깃값으로 할당되는 타입에 즉시 좁혀진다.)
    - 조건 검사를 통한 내로잉: if 문 내에서
    - typeof 검사를 통한 내로잉: typeof 연산자 사용. (if, else, 삼항연산자,! 논리적부정 등 조건문 안에서 typeof 사용)
- 리터럴 타입: 좀 더 구체적인 버전의 원시 타입. 원시 타입 값 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입. Let lifespan: number | “ongoing” | “uncertain” (유니언 타입 애너테이션에서 리터럴과 원시 타입을 섞어서 사용할 수 있다.)에서 "ongoing", "uncertain". 리터럴 타입은 그 값이 해당하는 원시 타입에 할당할 수 있다. 모든 특정 리터럴 문자열은 여전히 string 타입이기 때문이다. 특정 리터럴 타입 const 변수 vs 원시 타입 let 변수.
- 타입스크립트에는 재사용하는 타입에 더 쉬운 이름을 할당하는 타입 별칭(type alias)이 있습니다. 타입 별칭은 type 새로운 이름 = 타입 형태를 갖습니다. 편의상 타입 별칭은 파스칼 케이스로 이름을 지정합니다. (type RawData = boolean | number | string | null | undefined;)
다른 타입 별칭을 참조할 수 있다. 유니언 타입인 타입 별칭 내에 또 다른 유니언 타입인 타입 별칭을 포함하고 있다면 다른 타입 별칭을 참조하는 것이 유용하다.
```
type Id = number | string;
type IdMaybe = Id | undefined | null; 
// IdMaybe 타입은 number | string | undefined | null
// Id, IdMaybe 선언 순서 뒤바뀌어도 됨
```


# 📚 4장 객체

- 대부분의 타입스크립트 프로젝트는 객체 타입을 설명할 때 인터페이스 키워드를 사용하는 것을 선호한다.
- 선택적 속성과 undefined를 포함한 유니언 타입의 속성 사이에는 차이가 있다. ?를 사용해 선택적으로 선언된 속성은 존재하지 않아도 된다. 필수로 선언된 속성과 | undefined는 그 값이 undefined일지라도 반드시 존재해야 한다.
```
type Writers = {
  author: string | undefined;
  editor?: string;
};

// OK
Const hasRequired: Writers = {
  author: undefined,
};

// Error
Const missingRequired: Writers = {};
```

- 타입스크립트에서도 & 교차 타입(intersection type)을 사용해 여러 타입을 동시에 나타낸다. 교차타입은 유용한 개념이지만, 타입스크립트 컴파일러를 혼동시키는 방식으로 사용하기 쉽다. 교차 타입을 사용할 때는 가능한 한 코드를 간결하게 유지해야 한다.
    - 긴 할당 가능성 오류: 유니언 타입과 결합하는 것처럼 복잡한 교차 타입을 만들게 되면 할당 가능성 오류 메세지는 읽기 어려워진다. type을 쪼개서 type ShortPoem = Haiku | Villanelle 이와같이 해야 오류 메세지에서도 많은 타입이 나열되서 길어지지않고 해당 타입명만 나와서 읽기 좋다.
    - Never: 원시 타입의 값 두 개 시도하면 never 키워드로 표시되는 never 타입이 됨.