# [러닝 타입스크립트] Chapter.1 ~ Chapter.4 정리

## 정리

### JSDoc은 규모가 있는 코드베이스에서 사용하기 불편하다. (p.36)

- JSDoc 설명이 코드가 잘못되는 것을 막을 수 없다.
- JSDoc 설명이 이전에는 정확했더라도 코드 리팩터링 중에 생긴 변경 사항과 관련된 현재 유효하지 않은 JSDoc 주석을 모두 찾기란 어렵다.
- 복잡한 객체를 설명할 때는 다루기 어렵고 장황해서 타입과 그 관계를 정의하려면 다수의 독립형 주석이 필요하다.

### TypeScript는 무엇일까요? (p.37)

- **`프로그래밍 언어`**: 자바스크립트의 모든 구문과 타입을 정의하고 사용하기 위한 새로운 타입스크립트 고유 구문이 포함된 언어
- **`타입 검사기`**: 자바스크립트 및 타입스크립트로 작성된 일련의 파일에서 생성된 모든 구성 요소(변수, 함수 등)를 이해하고, 잘못 구성된 부분을 알려주는 프로그램
- **`컴파일러`**: 타입 검사기를 실행하고 문제를 보고한 후 이에 대응되는 자바스크립트 코드를 생성하는 프로그램
- **`언어 서비스`**: 타입 검사기를 사용해 VS Code와 같은 편집기에 개발자에게 유용한 유틸리티 제공법을 알려주는 프로그램

### tsconfig.json의 역할 (p.43, p.45)

```md
tsconfig.json 파일은 타입스크립트가 코드를 분석할 때 사용하는 설정을 선언합니다.
```

```md
tsc를 실행해 폴더의 모든 파일을 컴파일하도록 지시할 수 있고, 타입스크립트가 모든 구성 옵션에 대해서
tsconfig.json을 참조할 수 없다는 것
```

```md
편집기에서 특정 폴더를 열었을 때, tsconfig.json이 있으면 편집기가 해당 폴더를 타입스크립트 프로젝트로
인식한다는 것
```

### TypeScript의 설계 목표

- 현재와 미래의 ECMA스크립트 제안에 맞춘다
- 모든 자바스크립트 코드의 런타임 동작을 유지한다

### 유니언과 내로잉 (p.63)

- **`유니언`**: 값에 허용된 타입을 두 개 이상의 가능한 타입으로 **확장**하는 것
- **`내로잉`**: 값에 허용된 타입이 하나 이상의 가능한 타입이 되지 않도록 **좁히는** 것

### 유니언 속성 (p.65)

```md
객체가 어떤 속성을 포함한 타입으로 확실하게 알려지지 않은 경우, 타입스크립트는 해당 속성을 사용하려고
시도하는 것이 안전하지 않다고 여깁니다. 그런 속성이 존재하지 않을 수도 있으니까요.
```

### 리터럴 타입 (p.69)

- **리터럴 타입**
    - 원시 타입 값 중 어떤 것이 아닌 특정 원싯값으로 알려진 타입
- **원시 타입**
    - 해당 타입이 가질 수 있는 가능한 모든 리터럴 값의 전체 조합

### 타입 별칭 (p.76 ~ p.77)

```md
타입 별칭은 타입 애너테이션처럼 자바스크립트로 컴파일되지 않습니다.

타입 별칭은 순전히 '개발 시'에만 존재합니다.

사용 순서대로 타입 별칭을 선언할 필요는 없습니다. 파일 내에서 타입 별칭을 먼저 선언하고 참조할 타입 별칭을
나중에 선언해도 됩니다.
```

### 얕은 복사된 객체의 타입 (p.79)

```md
{ ... } 구문을 사용해서 객체 리터럴을 생성하면, 타입스크립트는 해당 속성을 기반으로 새로운 객체 타입 또는
타입 형태를 고려합니다. 해당 객체 타입은 객체의 값과 동일한 속성명과 원시 타입을 갖습니다.
```

## 새롭게 알게된 부분

### TypeScript와 컴파일 (p.44)

```md
타입스크립트 컴파일러는 타입 오류와는 상관없이 입력 파일로부터 자바스크립트를 계속 생성합니다.
```

### TypeScript의 원시 타입은 왜 소문자일까? (p.51)

```md
자바스크립트에서 객체와 원시 타입 간의 차이점을 떠올려보세요. Boolean과 Number와 같은 객체는
각 원싯값을 감싸는 객체입니다. 타입스크립트에서는 일반적으로 boolean과 number처럼 소문자로
참조하는 것이 모범 사례입니다.
```

### 타입 애너테이션 (p.56)

```ts
let rocker: string

rocker = 'Joan Jett'
```

- 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문
- 타입스크립트에서만 존재하며 런타임 코드에 영향을 주지도 않음
    - 타입 시스템에만 존재하는 것은 컴파일된 자바스크립트로 복사되지 않음, 타입스크립트 타입은 컴파일을 통해 생성된 자바스크립트에 영향을 주지 않음
- 유효한 자바스크립트 구문이 아님
- tsc 명령어를 실행해 타입스크립트 소스 코드를 자바스크립트로 컴파일하면 해당 코드가 살제됨

### 모듈과 스크립트 (p.60)

```ts
// a.ts
const shared = 'Cher'

// b.ts
const shared = 'Cher'
// Error: ~~~~~
```

```md
파일이 스크립트면 타입스크립트는 해당 파일을 전역 스코프로 간주하므로 모든 스크립트가 파일의 내용에 접근할 수
있습니다. 즉, 스크립트 파일에 선언된 변수는 다른 스크립트 파일에 선언된 변수와 동일한 이름을 가질 수 없습니다.

a.ts와 b.ts 파일은 모듈 스타일의 export 또는 import 문이 없기 때문에 일반 스크립트로 간주됩니다.
따라서 동일한 이름의 변수가 동일한 파일에 선언된 것처럼 서로 충돌합니다.

타입스크립트 파일에 Cannot redeclare...라는 오류가 표시되면 파일에 아직 export 또는 import문을
추가하지 않았기 때문일 수 있습니다. ECMA스크립트 사양에 따라 export 또는 import문 없이 파일을
모듈로 만들어야 한다면 파일의 아무 곳에나 export{};를 추가해 강제로 모듈이 되도록 만듭니다.
```

```ts
// a.ts and b.ts
const shared = 'Cher'

export {}
```

### 십억 달러의 실수 (p.72)

```md
'십업 달러의 실수'는 다른 타입이 필요한 위치에서 null 값을 사용하도록 허용하는 많은 타입 시스템을
가리키는 업계 용어

엄격한 null 검사가 없는 언어에서는 다음 예제 코드처럼 string 타입 변수에 null을 할당하는 것이 허용됩니다.
const firstName: string = null
```

### 초과 속성 검사 우회하는 방법 (p.85)

```ts
type Poet = {
  born: number;
  name: string;
}

const existingObject: Poet = {
  activity: "walking", // Error: ~~~~~~~~~~
  born: 1935,
  name: 'Mary Oliver'
}

const existingObject = {
  activity: "walking",
  born: 1935,
  name: 'Mary Oliver'
}

const extraPropertyButOk: Poet = existingObject //OK
```

## 다시 찾아보면 좋을 것 같은 부분

### 타입 시스템의 동작 과정 (p.51)

```md
타입 시스템은 프로그래밍 언어가 프로그램에게서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합
```

1. 코드를 읽고 존재하는 모든 타입과 값을 이해합니다.
2. 각 값이 초기 선언에서 가질 수 있는 타입을 확인합니다.
3. 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인합니다.
4. 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시합니다.

### 타입 추론 과정 (p.52)

```ts
let firstName = "Whitney"
firstName.length()
```

1. 코드를 읽고 firstName이라는 변수를 이해합니다.
2. 초깃값이 “Whitney”이므로 firstName이 string 타입이라고 결론짓습니다.
3. firstName의 .length 멤버를 함수처럼 호출하는 코드를 혹인합니다.
4. string의 .length 멤버는 함수가 아닌 숫자라는 오류를 표시합니다. **즉, 함수처럼 호출할 수 없습니다.**

### TypeScript 오류 종류 (p.52 ~ p.53)

- **구문 오류**
  - 타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지할 때 발생
  - 타입스크립트가 타입스크립트 파일에서 자바스크립트 파일을 올바르게 생성할 수 없도록 차단
- **타입 오류**
  - 타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생
  - 오류가 발생했다고 해서 타입스크립트 구문이 자바스크립트로 변환되는 것을 차단하지 않음

### 할당 가능성과 오류 (p.55)

- 할당 가능성
  - 타입스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것
    (== 전달된 값이 예상된 타입으로 할당 가능한지 여부 확인)
- 오류 메시지
  - 첫 번째 타입: 코드에서 변수에 할당하려고 시도하는 값
  - 두 번째 타입: 값이 할당되는 변수(첫 번째 타입)

### 모듈에서의 타입 추론 (p.61)

```md
타입스크립트는 CommonJS와 같은 이전 모듈을 사용해서 작성된 타입스크립트 파일의 import, export 형태는
인식하지 못합니다. 타입스크립트는 일반적으로 CommonJS 스타일의 require 함수에서 반환된 값을 any 타입으로
인식합니다.
```

### 논리 연산자와 undefined (p.74)

```md
논리 연산자인 &&와 ?는 참 여부를 검사하는 일도 잘 수행합니다. 하지만 안타깝게도 참 여부 확인 외에
다른 기능은 제공하지 않습니다.

그것이 빈 문자열인지 undefined인지는 알 수 없습니다.

빈 문자열인 경우에는 여전히 string이 될 수 있음을 알 수 있습니다.
```

### 구조적 타이핑과 덕 타이핑 (p.82 ~ p.83)

```md
타입스크립트의 타입 시스템은 구조적으로 타입화되어 있습니다. 즉, 타입을 충족하는 모든 값을 해당 타입의 값으로
사용할 수 있습니다.

매개변수나 변수가 특정 객체 타입으로 선언되면 타입스크립트에 어떤 객체를 사용하든 해당 속성이 있어야만 한다고
말해야 합니다.

구조적 타이핑은 덕 타이핑과는 다릅니다.

자바스크립트는 덕 타입인 반면 타입스크립트는 구조적으로 타입화됩니다.
```

- 타입스크립트의 타입 검사기에서 구조적 타이핑은 정적 시스템이 타입을 검사하는 경우입니다.
- 덕 타이핑은 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것을 말합니다.
  - 덕 타이핑은 동적 타이핑의 한 종류로 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 의미

### 초과 속성 검사 (p.84 ~ p.85)

```md
변수가 객체 타입으로 선언되고, 초깃값에 객체 타입에서 정의된 것보다 많은 필드가 있다면 타입스크립트에서
타입 오류가 발생합니다. 변수를 객체 타입으로 선언하는 것은 타입 검사기가 해당 타입에 예상되는 필드만 있는지
확인하는 방법입니다.

초과 속성 검사는 객체 타입으로 선언된 위치에서 생성되는 객체 리터럴에 대해서만 일어납니다. 기존 객체 리터럴을
제공하면 초과 속성 검사를 우회합니다.
```

## 궁금한 부분

### Q. JSDoc vs TS

- https://github.com/sveltejs/svelte/pull/8569

### Q. TS는 JS보다 느리다 챕터에서 분리된 채로 수행된다는 게 어떤 의미인지? (p.47)

```jsx
코드에서 발생할 수 있는 오류를 분석하는 느린 타입스크립트 기능은 실행 가능한 애플리케이션 코드 파일을
생성하는 것과는 분리된 채로 수행됩니다.
```

### Q. redeclare 에러 경험?

```ts
// a.ts and b.ts
const shared = 'Cher'
```

### Q. 사용하고 있는 내로잉 방법?

```ts
// 1. if문
if (validSession) {
  // ...
}

// 2. if문 + in
if ('token' in validSession) {
  // ...
}

// 3. type predicate
const isValidSession = (session: ValidSession | InvalidSession): session is ValidSession => !!(session.token)

// 4. assert
const session = newSession as ValidSession

// 5. typeof + if
```