## Ch.1 자바스크립트에서 타입스크립트로

#### 타입스크립트의 장점

1. 보다 본질적인 자유 <br/>
   타입스크립트에서는 오류가 발생하는 코드가 자바스크립트에서는 오류 없이 실행됩니다. 그렇다면 자바스크립트가 코드 작성에 더 자유로운 걸까요? 아닙니다. 오류는 발생하지 않더라도 실행된 결과는 예상했던 것과 다를 것입니다. 결국 런타임 전까지만 누리는 찰나의 자유인 셈입니다. <br/>

2. 정확한 문서화 <br/>

타입스크립트는 구문을 적용해 객체의 형태를 설명합니다. 이 우수하고 강력한 시스템 덕에 처음 보는 코드에서도 해당 객체가 어떤 속성들을 가지고 있는지, 어떤 것이 메서드인지 한눈에 파악할 수 있습니다. <br/>

3. 더 강력한 개발자 도구 <br/>

VS Code 같은 편집기에서 타입스크립트로 코드를 작성하면 편집기가 코드를 좀 더 깊이 이해하게 됩니다. 그리고 이 이해를 바탕으로 우리가 코드를 작성할 때 문자열 자동 완성 같은 훌륭한 제안을 제공해줍니다.

4. 모두를 위한 프로그래밍 언어 <br/>

타입스크립트는 자바스크립트 코드를 구조화하지만, 타입 안정성 강화를 제외하곤 구조의 방식에 대해 제한하지 않습니다. 또한 어떤 코드 스타일도 강요하지 않으며, 모든 프레임워크에서 사용 가능합니다. 그래서 자바스크립트에서 사용하던 아키텍처 패턴 중 어떤 것을 사용할 수 있고, 타입스크립트가 이를 지원합니다.

## Ch.2 타입 시스템

타입스크립트의 타입 시스템은 각 값이 초기 선언에서 가질 수 있는 타입을 확인하고, 추후 코드에서 어떻게 사용되는지 사용법을 확인합니다. 그리고 그 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시합니다. <br/>

우리가 가장 자주 접하게 되는 오류는 크게 두 가지 입니다.

1. 구문 오류<br/>
   구문 오류는 타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지했을 때 발생합니다. 이 경우 타입스크립트가 타입스크립트 파일에서 자바스크립트로 변환되는 것을 차단합니다. tsc 설정을 통해 자바스크립트 코드를 얻을 수는 있지만, 올바른 결과값을 보장할 수 없으니 구문을 수정하는 것이 좋습니다.

2. 타입 오류<br/>
   타입 오류는 말 그대로 타입에서 오류를 감지했을 때 발생합니다. 이 경우 자바스크립트로 변환되는 것을 차단하지는 않습니다. 하지만 실행됐을 경우 예기치 않게 동작할 수 있기 때문에 역시 타입 오류를 먼저 해결하는 것이 좋습니다.

#### 할당 가능성

타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정합니다. 나중에 해당 변수에 새로운 값이 할당되면 새로 할당된 값이 기존의 타입과 일치하는지 확인합니다. 이처럼 전달된 값이 예상되는 타입으로 할당 가능한지 여부를 확인하는 것을 `할당 가능성`이라고 합니다.

#### 타입 에너테이션

변수에 초기값이 없는 경우 타입스크립트는 암묵적으로 해당 변수를 `any` 타입으로 간주합니다. any 타입을 가진 값에는 타입스크립트가 가진 검사 기능을 활용할 수 없습니다. 그래서 타입스크립트는 `타입 에너테이션`이라는 구문을 제공합니다.

```
let KimSeongYeon: string;
KimSeongYeon = "My love"
```

이런 타입 에너테이션은 타입스크립트에만 존재하며 런타임 코드에 영향을 주지도 않고, 유효한 자바스크립트 구문도 아닙니다. 하지만 이 구문 덕에 코드를 명확하게 문서화하거나 실수로 타입이 변경되지 않도록 보호할 수 있습니다.

#### 모듈

이 책에서는 다음과 같은 명명법을 사용합니다.

> 모듈: export 또는 import가 있는 파일<br/>
> 스크립트: 모듈이 아닌 모든 파일

모듈 파일에 선언된 모든 것은 해당 파일에서 명시한 export 문에서 내보내지 않는 한 모듈 파일에서만 사용할 수 있습니다. 하지만 스크립트 파일은 타입스크립트가 해당 파일을 전역 스코프로 간주하므로, 스크립트 파일에 선언된 변수는 다른 스크립트 파일에 선언된 변수와 동일한 이름을 가질 수 없습니다. <br/>

그러니 만약 타입스크립트 파일에 `Cannot redeclare...` 라는 오류가 표시되면 파일에 아직 export나 import 문을 추가하지 않았기 때문일 수 있습니다. export나 import 문 없이 모듈을 만들고 싶다면 파일의 아무 곳에나 `export {};`를 추가해 강제로 모듈을 만들어줄 수도 있습니다.

> 궁금증: 61쪽에 있는 warning에서 이전 모듈을 사용해서 작성된 타입스크립트의 import, export 형태는 인식하지 못한다는 게 무슨 말인가요?

## Ch.3 유니언과 리터럴

타입스크립트가 해당 값을 바탕으로 추론을 수행하는 두 가지 핵심 개념이 있습니다. 바로 `유니언`과 `내로잉`입니다. 이 두 가지는 다른 주요 프로그래밍 언어에서는 불가능하고 타입스크립트에서만 가능한 강력한 개념입니다.

#### 유니언 타입

앞서 말씀드린 '유니언'은 값에 허용된 타입을 두 개 이상의 가능한 타입으로 확장하는 것을 말합니다. 쉽게 말하자면 '이거 혹은 저거'라고 할 수 있겠네요. 유니언 타입은 값이 정확히 어떤 타입인지 모르지만 두 개 이상의 옵션 중 하나라는 것을 알고 있는 경우에 코드를 처리하는 유용한 개념입니다. <br/>

주의할 점은 값이 유니언 타입일 때 타입스크립트는 유니언으로 선언한 모든 가능한 타입에 존재하는 속성에만 접근할 수 있습니다. 이외에는 타입 검사 오류가 발생합니다.<br/>

예를 들어

```
let judoka = Math.random()> 0.5
? "Kim Seong Yeon"
: 52
```

위의 코드에서 judoka는 두 개의 타입에 모두 존재하는 `.toString()`은 사용할 수 있지만, `toUpperCase()`나 `toFixed()`는 사용할 수 없습니다.<br/>

객체가 어떤 속성을 포함한 타입인지 확실하게 알려지지 않은 경우, 타입스크립트는 해당 속성을 사용하지 않는 것이 안전하다고 간주하기 때문입니다. 유니언 타입으로 정의된 여러 타입 중 하나의 타입으로 된 값의 속성을 사용하려면 이 값의 보다 구체적인 타입을 타입스크립트에게 알려줘야 합니다. 이 과정을 `내로잉`이라고 합니다.

#### 내로잉

1. 값 할당을 통한 내로잉 <br/>
   유니언 타입 애너테이션이 명시된 후 초기값이 주어지면 초기값의 타입으로 값 할당 내로잉이 작동합니다.<br/>
2. 조건 검사를 통한 내로잉 <br/>
   if문처럼 조건부 로직으로 내로잉을 할 수 있습니다.<br/>
   3.typeof 검사를 통한 내로잉 <br/>
   typeof 연산자를 통해 내로잉을 할 수도 있습니다. 보통 if문과 결합해서 사용할 수 있으며 !를 이용한 논리적 부정과 else문도 잘 작동합니다. <br/>

#### 리터럴

리터럴은 간단히 말해 '좀 더 구체적인 원시 타입'입니다.

```
const judoka = "Kim Seong Yeon";
```

이 경우 judoka의 타입은 단순한 string 타입이 아닌 좀 더 구체적인 "Kim Seong Yeon" 입니다. 변수를 const로 선언하고 직접 리터럴 값을 할당하면 타입스크립트는 해당 변수를 할당된 리터럴 값으로 유추합니다.

이처럼 리터럴로 좁혀진 유니언의 힘은 엄격한 null 검사에서 두드러집니다.

## Ch.4 객체

자바스크립트는 덕 타이핑입니다. 덕 타이핑이란 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것을 말합니다. 반면 타입스크립트는 정적 시스템이 타입을 검사하는 구조적 타이핑입니다.

객체 타입으로 애너테이션 된 위치에 값을 제공할 때 타입스크립트는 값을 해당 객체 타입에 할당할 수 있는지 확인합니다. 할당하는 값에는 객체 타입의 필수 속성이 모두 있어야 합니다. 초과 속성 역시 금지됩니다. 초과 속성 검사는 기존 객체 리터럴을 통해 우회할 수 있지만, 되도록이면 초과 속성을 금지했을 때 보다 안전하게 작동하는 코드를 만들 수 있습니다.

#### 객체 타입 내로잉

코드에서 객체의 형태를 확인하고 타입 내로잉을 객체에 적용할 수 있습니다.

```
if("pages" in Poem) {
poem.pages; // OK.poem은 PoemWithPages로 좁혀짐
}
```

하지만 아래와 같은 방식은 허용하지 않습니다.

```
if(poem.pages)
```
